#!/bin/bash

help ()
{
	echo "dsh - Drude Shell"
	echo "Usage: dsh <command>"
	echo "Commands list:"
	echo 
	echo "	start (up)		Start vagrant vm (mac, win) and docker containers -OR- restarts containers if vm is already running"
	echo "	stop (down, halt)	Stop vagrant vm (mac, win) or stop containers (linux)"
	echo "	reload (restart)	Re-start vagrant vm (mac, win) and docker containers (only restart containers on linux)"
	echo "	status (st)		Show vm/containers status"
	echo "	bash			Start bash on web container"
	echo "	run			Run a command in web container"
	echo "	  Usage: dsh run <command> <param> <param> <param>..."
	echo "	mysql			Open mysql shell"
	echo "	cc			Clears caches using \"drush cc <cache_type>\""
	echo "	  Usage: dsh cc <cache_type> (optional, if no <cache_type> specified runs \"drush cc all\")"
	echo "	help			Output this help"
	echo
}

#-------------------------- Helper functions --------------------------------

# Search for file in current dir and all parent dirs
# @param $1 filename
# @param $2 variable that gets result - a path to file if it was found
upfind ()
{
	if [[ $1 == '' ]]; then return 1; fi
	local up='../'
	local pathup='./'
	local slashes=${PWD//[^\/]/}
	for (( i=${#slashes}; i>0; --i )) ; do 
		if [ -f "${pathup}$1" ] ; then
			eval $2="${pathup}"
			break
		else
			pathup=$pathup$up
		fi
	done
}

# Returns absolute path 
get_abs_path ()
{
	local _dir
	if [ -f $1 ]; then
		_dir=`dirname $1`
	elif [ -d $1 ]; then
		_dir=$1
	else
		echo "Path \"$1\" does not exist"
		return
	fi
	local absolute=$( cd "${_dir}" ; pwd )
	eval $2="$absolute"
}

# Returns docroot absolute path
# @param $1 name of variable to get result
get_docroot_path ()
{
	if [ $# -ne 1 ]; then return; fi
	upfind "docker-compose.yml" yml_path
	# get relative docroot path from docker-compose.yml config
	local docroot_relative=$(grep "&docroot" ${yml_path}docker-compose.yml | sed 's/.*"\(.*\):.*$/\1/')
	local docroot_absolute=$( cd "${yml_path}$docroot_relative" ; pwd )
	eval $1="$docroot_absolute"
}

# dummy function to check that command is run along settings.php
get_drush_path ()
{
	if [ ! -f './settings.php' ]; then
		echo "dsh supports \"${argv[0]}\" command only from sites/yoursite directory which contains settings.php"
		return 1
	fi
	return 0
}

# Get current path relative to docroot
# @param $1 name of variable to get result
cmdpath ()
{
	if [[ $# -ne 1 ]]; then return; fi
	get_docroot_path docroot_path
	# leave only part of absolute path that is after docroot
	local cmdpath=${PWD#$docroot_path/}
	if [[ "$cmdpath" == "$(pwd)" ]] ; then
		# if replacement didnt happen then we are in docroot or higher
		eval $1="."
	else	
		eval $1="$cmdpath"
	fi
}

# Removes invisible residue from the string that remains leftover sometimes
# @param $1 string to cleanup
# @param $2 variable that receives clean string
clean_string ()
{
	cleaned=$(echo -e "$1" | sed -e 's/[^a-zA-Z0-9_-]$//')
	eval $2=\'${cleaned}\'
}

# get mysql connection string
# @param $1 gets result
get_mysql_connect ()
{
	# get connection string and cleanup residue that is leftover
	clean_string "$(_run drush sql-connect)" clean_res
	eval $1=\'$clean_res\'
}

#----------------------- Basics check functions -----------------------------

# checks if binary exists and callable in PATH
binary_found ()
{
	if [[ $1 == '' ]]; then
		return 1;
	fi

	local bpath=`which $1`
	
	if [[ $bpath != '' ]] && [ -f `which $1` ]; then
		return 0
	else
		echo "\"$1\" executable not found."
		return 1
	fi
}

# check that vagrant binary exists
is_vagrant ()
{
	binary_found 'vagrant';
	return $?
}

# check that docker-compose binary exists
is_docker_compose ()
{
	binary_found 'docker-compose';
	return $?
}

# check that docker binary exists
is_docker ()
{
	binary_found 'docker';
	return $?
}

is_linux ()
{
	local res=`uname | grep 'Linux'`
	if [[ ! $res == '' ]]; then
		return 0;
	else 
		return 1;
	fi
}

# Checks if yml or vagrantfile (win, mac) is absent
is_yml_absent ()
{
	local vagrant_path=''

	upfind "docker-compose.yml" yml_path
	if [ $yml_path == '' ] ; then
		echo "dsh: docker-compose.yml not found in your directory tree"
		return 0
	fi

	if is_linux ; then
		return 1; # linux does not need vagrant
	fi

	upfind "Vagrantfile" vagrant_path
	if [ $vagrant_path == '' ] ; then
		echo "dsh: Vagrantfile not found in your directory tree"
		return 0
	fi

	#if we got here files are present
	return 1
}

# Checks if vm exists (as per vagrant)
is_vm_exist ()
{
	if is_yml_absent ; then return 2; fi
	if is_linux ; then return 0; fi
	if is_vagrant ; then
		res=`vagrant status | grep -e "boot2docker.*not created"`
		if [[ $res == '' ]]; then
			return 0
		else 
			echo "dsh: Vagrant reports that boot2docker vm is not created. Please check you Vagrantfile or run \"dsh up\""
			return 1
		fi
	else
		return 2
	fi
}

# Checks if vm is stopped
is_vm_stopped ()
{
	if is_yml_absent ; then return 2; fi
	if is_linux ; then return 1; fi
	if is_vagrant ; then
		res=`vagrant status | grep -e "boot2docker.*running"`
		if [[ $res == '' ]]; then
			return 0
		else 
			return 1
		fi
	else
		return 2
	fi
}

#------------------------------- Commands -----------------------------------
# bring box up
up ()
{
	echo "Checking files..."
	if is_yml_absent ; then return 2; fi
	if ! is_vm_exist ; then return 2; fi
	if is_vagrant ; then
		echo "Starting vagrant vm..."
		vagrant up
		started=$?
		if [ $started -eq 0 ] && is_docker_compose ; then
			echo "Starting containers..."
			upfind "docker-compose.yml" yml_path
			cd $yml_path
			docker-compose up -d
		fi
	elif is_linux && is_docker_compose ; then
		echo "Starting containers..."
		upfind "docker-compose.yml" yml_path
		cd $yml_path
		docker-compose up -d
	fi
}

# stop box
down ()
{
	if is_yml_absent ; then return 2; fi
	if is_vagrant ; then
		echo "Stopping vagrant vm..."
		vagrant halt
	elif is_linux; then
		echo "Stopping containers..."
		upfind "docker-compose.yml" yml_path
		cd $yml_path
		docker-compose stop
	fi
}

# call 911
restart ()
{
	echo "Checking files..."
	if is_yml_absent ; then return 2; fi
	if ! is_vm_exist ; then return 2; fi
	if is_vagrant ; then
		echo "Restarting vagrant vm..."
		vagrant reload
		started=$?
		if [ $started -eq 0 ] && is_docker_compose ; then
			echo "Starting containers..."
			upfind "docker-compose.yml" yml_path
			cd $yml_path
			docker-compose up -d
		fi
	elif is_linux && is_docker_compose ; then
		echo "Restarting containers..."
		upfind "docker-compose.yml" yml_path
		cd $yml_path
		docker-compose up -d
	fi	
}

# output status of boot2docker if stopped or containers if started
status ()
{
	is_vm_stopped
	stopped=$?
	case $stopped in
		2)
			return
			;;
		1)
			if is_docker_compose ; then
				upfind "docker-compose.yml" yml_path
				cd $yml_path
				docker-compose ps
			fi
			;;
		0)
			echo "boot2docker is not running"
			if ! is_vm_exist ; then
				return
			else
				echo "Run \"dsh up\" to start boot2docker"
			fi
			;;
	esac
}

# start interactive bash in container
_bash ()
{
	upfind "docker-compose.yml" yml_path
	cd $yml_path
	if is_docker && is_docker_compose ; then
		docker exec -it $(docker-compose ps -q web) bash -i
		RES=$?
		if [ $RES -ne 0 ]; then
			echo
			echo "dsh: You might want to run \"dsh up\""
		fi
	fi
}

# Run a command in container in docroot
# param $* command with it's params to run
run ()
{
	if is_docker && is_docker_compose ; then
		upfind "docker-compose.yml" yml_path
		cd $yml_path
		docker exec -it $(docker-compose ps -q web) bash -ic "$*"
	fi
}

# Run a command in container changing dir to the same folder
# param $* command with it's params to run
_run ()
{
	if is_docker && is_docker_compose ; then
		local cd_path=''
		cmdpath cd_path
		run "cd $cd_path && $*" 
	fi
}

# start interactive mysql shell
mysql ()
{
	if ! get_drush_path; then return; fi
	local sql_connect
	get_mysql_connect sql_connect
	_run $sql_connect" -A" # -A option to speed up mysql load
}

# Truncate db and import from sql dump
# @param $1 filename of backup file. Should be inside docroot
mysql_import ()
{
	if ! get_drush_path; then return; fi
	local docroot
	get_docroot_path docroot
	local filename=`basename $1`
	local filepath
	get_abs_path $1 filepath
	#substract docroot path from filepath
	local pathdiff=${filepath#$docroot}

	if [[ $pathdiff == $filepath ]] ; then
		# substraction did not succeed because file is outside docroot
		echo "\"$filename\" should be inside your docroot folder"
		return
	fi

	#run "ls $filename"

	local sql_connect
	get_mysql_connect sql_connect
	#_run 'echo "use drupal; show tables;" | '$sql_connect
	echo "Importing $filename into database 'drupal'..."
	run $sql_connect" < $filename"
}

# Shortcut to run drush cc ... on site
# @param $1 type of cache to clean (all, css-js, ...)
clear_cache ()
{
	if ! get_drush_path; then return; fi
	local type='all'
	if [[ ! $1 == '' ]]; then 
		type=$1
	fi
	_run 'drush cc '$type
}

# command bindings
argv=("$@")
case $1 in
	up)
		up
		;;
	start)
		up
		;;
	stop)
		down
		;;
	down)
		down
		;;
	halt)
		down
		;;
	restart)
		restart
		;;
	reload)
		restart
		;;
	status)
		status
		;;
	st)
		status
		;;
	bash)
		_bash
		;;
	run)
		shift
		_run $*
		;;
	mysql)
		mysql
		;;
	mysql-import)
		mysql_import $2
		;;
	cc)
		clear_cache $2
		;;
	*)
		help
		exit 0
esac
